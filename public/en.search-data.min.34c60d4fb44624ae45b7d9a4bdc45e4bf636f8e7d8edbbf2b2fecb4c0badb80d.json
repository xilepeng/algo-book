[{"id":0,"href":"/docs/leetcode/3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","title":"3. 无重复字符的最长子串","section":"Docs","content":" 3. 无重复字符的最长子串 # 方法一：滑动窗口\nfunc lengthOfLongestSubstring(s string) int { longest, n := 0, len(s) // len(s)返回字符串的字节数目（不是rune字符数目） index := make(map[byte]int, n) // m 记录字节索引，byte 可避免额外的字节/字符串转换 for left, right := 0, 0; right \u0026lt; n; right++ { if idx, ok := index[s[right]]; ok { // 如果第i个字节已存在 left = max(left, idx+1) // 取索引较大值作为起始索引（收缩窗口） } index[s[right]] = right // 首次出现加入map，记录字节对应的索引 longest = max(longest, right-left+1) // 统计无重复字符的最长子串 } return longest } func lengthOfLongestSubstring(s string) int { longest, n := 0, len(s) index := make(map[byte]int, n) // 记录字符对应的下标 for left, right := 0, 0; right \u0026lt; n; right++ { // right++ 指针继续向后扫描 if idx, ok := index[s[right]]; ok \u0026amp;\u0026amp; idx \u0026gt;= left { // 遇到重复字符，跳过 left = idx + 1 // 收缩窗口 } index[s[right]] = right //首次遇见，存储对应下标 longest = max(longest, right-left+1) } return longest } func lengthOfLongestSubstring(s string) int { longest, n := 0, len(s) freq := make(map[byte]int, n) // freq 记录每个字节出现次数，byte 可避免额外的字节/字符串转换 for i, j := 0, 0; j \u0026lt; n; j++ { freq[s[j]]++ // 首次出现存入哈希表，记为1 for freq[s[j]] \u0026gt; 1 { // 循环检测：如果大于1，表示当前字节有重复 freq[s[i]]-- // 去重，直到 freq[s[j]] == 1,退出 i++ // 向后扫描 if freq[s[j]] == 1 { // 优化：如果无重复字符，则退出循环 break } } longest = max(longest, j-i+1) // 统计无重复字符的最长子串 } return longest } 方法二：位图\nfunc lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } var bitSet [256]bool result, left, right := 0, 0, 0 for left \u0026lt; len(s) { // 右侧字符对应的 bitSet 被标记 true，说明此字符在 X 位置重复，需要左侧向前移动，直到将 X 标记为 false if bitSet[s[right]] { // s[right]第2次出现，与s[left]标记位重复 bitSet[s[left]] = false // 放弃 s[left] 标记位 left++ // 跳过重复，向后扫描 } else { bitSet[s[right]] = true // s[right]第1次出现，标记为true，选择 s[right] 标记位 right++ // 向后扫描 } if result \u0026lt; right-left { result = right - left } if left+result \u0026gt;= len(s) || right \u0026gt;= len(s) { break } } return result } "},{"id":1,"href":"/docs/leetcode/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","title":"206. 反转链表","section":"Docs","content":" 206. 反转链表 # 方法一：迭代\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { var prev *ListNode curr := head for curr != nil { temp := curr.Next curr.Next = prev prev = curr curr = temp } return prev } 方法二：递归\nfunc reverseList_2(head *ListNode) *ListNode { if head == nil || head.Next == nil { // 递归出口：没有节点或只有一个节点 return head } newHead := reverseList(head.Next) // 子问题 head.Next.Next = head // 翻转 head.Next = nil // 断开旧链 return newHead } 方法三：穿针引线\nfunc reverseList_3(head *ListNode) *ListNode { dummy, curr := \u0026amp;ListNode{Next: head}, head for curr != nil \u0026amp;\u0026amp; curr.Next != nil { // 至少有2个节点 temp := curr.Next curr.Next = temp.Next temp.Next = dummy.Next // 如果等于 curr，将导致断开链表 dummy.Next = temp } return dummy.Next } "}]