---
weight: 1
---


## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

方法一：滑动窗口

``` go
func lengthOfLongestSubstring(s string) int {
	longest, n := 0, len(s)        // len(s)返回字符串的字节数目（不是rune字符数目）
	index := make(map[byte]int, n) // m 记录字节索引，byte 可避免额外的字节/字符串转换
	for left, right := 0, 0; right < n; right++ {
		if idx, ok := index[s[right]]; ok { // 如果第i个字节已存在
			left = max(left, idx+1) // 取索引较大值作为起始索引（收缩窗口）
		}
		index[s[right]] = right              // 首次出现加入map，记录字节对应的索引
		longest = max(longest, right-left+1) // 统计无重复字符的最长子串
	}
	return longest
}
```

```go
func lengthOfLongestSubstring(s string) int {
	longest, n := 0, len(s)
	index := make(map[byte]int, n)                // 记录字符对应的下标
	for left, right := 0, 0; right < n; right++ { // right++ 指针继续向后扫描
		if idx, ok := index[s[right]]; ok && idx >= left { // 遇到重复字符，跳过
			left = idx + 1 // 收缩窗口
		}
		index[s[right]] = right //首次遇见，存储对应下标
		longest = max(longest, right-left+1)
	}
	return longest
}
```

```go
func lengthOfLongestSubstring(s string) int {
    longest, n := 0, len(s)
    freq := make(map[byte]int, n) // freq 记录每个字节出现次数，byte 可避免额外的字节/字符串转换
    for i, j := 0, 0; j < n; j++ {
        freq[s[j]]++         // 首次出现存入哈希表，记为1
        for freq[s[j]] > 1 { // 循环检测：如果大于1，表示当前字节有重复
            freq[s[i]]--         // 去重，直到 freq[s[j]] == 1,退出
            i++                  // 向后扫描
            if freq[s[j]] == 1 { // 优化：如果无重复字符，则退出循环
                break
            }
        }
        longest = max(longest, j-i+1) // 统计无重复字符的最长子串
    }
    return longest
}
```

方法二：位图

```go
func lengthOfLongestSubstring(s string) int {
	if len(s) == 0 {
		return 0
	}
	var bitSet [256]bool
	result, left, right := 0, 0, 0
	for left < len(s) {
		// 右侧字符对应的 bitSet 被标记 true，说明此字符在 X 位置重复，需要左侧向前移动，直到将 X 标记为 false
		if bitSet[s[right]] { // s[right]第2次出现，与s[left]标记位重复
			bitSet[s[left]] = false // 放弃 s[left] 标记位
			left++                  // 跳过重复，向后扫描
		} else {
			bitSet[s[right]] = true // s[right]第1次出现，标记为true，选择 s[right] 标记位
			right++                 // 向后扫描
		}
		if result < right-left {
			result = right - left
		}
		if left+result >= len(s) || right >= len(s) {
			break
		}
	}
	return result
}
```




